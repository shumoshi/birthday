<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Zen+Kurenaido&display=swap" rel="stylesheet">
    <title>桃子生誕祭2DAYS - スクラッチ</title>
    <style>
        /* ---CSSは元のまま--- */
    </style>
</head>
<body>
    <div class="lottery-container">
        <!-- ...省略... -->
    </div>

    <!-- サウンド -->
    <audio id="bgm-audio" src="bgm.mp3" loop></audio>
    <audio id="scratch-audio" src="scratch.mp3" loop></audio>
    <audio id="kansei-audio" src="kansei.mp3"></audio>

    <script>
        // 既存コード（prizes, scratchImages, winningAreas など全てそのまま）

        // サウンド系
        window.addEventListener('load', function() {
            // 既存onload内容はこのあとに続けてOK
            const bgm = document.getElementById('bgm-audio');
            if (bgm) {
                bgm.volume = 0.12;
                document.body.addEventListener('click', ()=>{ if(bgm.paused) bgm.play().catch(()=>{}); }, { once: true });
                bgm.play().catch(()=>{});
            }
            // ...既存の初期化（画像セット等）...
            const missionInfo = document.getElementById('missionInfo');
            missionInfo.innerHTML = `ミッション${missionNumber}完了おめでとう♡<br>スクラッチを削って景品を確認しよう！`;

            // スクラッチ画像を設定
            const scratchImage = document.getElementById('scratchImage');
            scratchImage.src = scratchImages[missionNumber];

            scratchImage.onload = function() {
                initScratchAreas();
            };
        });

        // ---スクラッチ音追加！---
        function setupScratchEvents(canvas, ctx, areaType) {
            let isScratching = false;
            let scratchedPixels = 0;
            const totalPixels = canvas.width * canvas.height;
            const threshold = areaType === 'red' ? 0.9 : 0.8;

            const scratchAudio = document.getElementById('scratch-audio');

            function startScratch(e) {
                isScratching = true;
                // スクラッチ音再生
                if (scratchAudio && scratchAudio.paused) {
                    scratchAudio.currentTime = 0;
                    scratchAudio.play().catch(()=>{});
                }
                scratchAt(getEventPos(e));
            }
            function scratch(e) {
                if (!isScratching) return;
                scratchAt(getEventPos(e));
            }
            function stopScratch() {
                isScratching = false;
                if (scratchAudio) scratchAudio.pause();
            }
            function getEventPos(e) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX || e.pageX || e.touches[0].clientX) - rect.left;
                const y = (e.clientY || e.pageY || e.touches[0].clientY) - rect.top;
                return { x, y };
            }
            function scratchAt(pos) {
                createScratchParticles(pos, canvas);
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0,0,0,1)';
                ctx.fill();
                checkScratchProgress();
            }
            function checkScratchProgress() {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let transparent = 0;
                for (let i = 3; i < imageData.data.length; i += 4) {
                    if (imageData.data[i] < 128) transparent++;
                }
                const percent = transparent / (canvas.width * canvas.height);
                if (percent > threshold) {
                    revealAll(canvas, areaType);
                    if (scratchAudio) scratchAudio.pause();
                }
            }
            canvas.addEventListener('mousedown', startScratch);
            canvas.addEventListener('mousemove', scratch);
            canvas.addEventListener('mouseup', stopScratch);
            canvas.addEventListener('mouseleave', stopScratch);
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                startScratch(e.touches[0]);
            });
            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
                if (isScratching) scratch(e.touches[0]);
            });
            canvas.addEventListener('touchend', stopScratch);
        }

        // ダミーエリアも同様
        function setupDummyScratchEvents(canvas, ctx) {
            let isScratching = false;
            const scratchAudio = document.getElementById('scratch-audio');
            function startScratch(e) {
                isScratching = true;
                if (scratchAudio && scratchAudio.paused) {
                    scratchAudio.currentTime = 0;
                    scratchAudio.play().catch(()=>{});
                }
                scratchAt(getEventPos(e));
            }
            function scratch(e) {
                if (!isScratching) return;
                scratchAt(getEventPos(e));
            }
            function stopScratch() {
                isScratching = false;
                if (scratchAudio) scratchAudio.pause();
            }
            function getEventPos(e) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX || e.pageX || e.touches[0].clientX) - rect.left;
                const y = (e.clientY || e.pageY || e.touches[0].clientY) - rect.top;
                return { x, y };
            }
            function scratchAt(pos) {
                createScratchParticles(pos, canvas);
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(0,0,0,1)';
                ctx.fill();
            }
            canvas.addEventListener('mousedown', startScratch);
            canvas.addEventListener('mousemove', scratch);
            canvas.addEventListener('mouseup', stopScratch);
            canvas.addEventListener('mouseleave', stopScratch);
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                startScratch(e.touches[0]);
            });
            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
                if (isScratching) scratch(e.touches[0]);
            });
            canvas.addEventListener('touchend', stopScratch);
        }

        // 景品表示時に「kansei.mp3」
        function showResult() {
            const kanseiAudio = document.getElementById('kansei-audio');
            if (kanseiAudio) {
                kanseiAudio.currentTime = 0;
                kanseiAudio.play().catch(()=>{});
            }
            // 以降は元の処理
            const result = document.getElementById('lotteryResult');
            const buttons = document.getElementById('actionButtons');
            const prizeElement = document.getElementById('resultPrize');
            const descElement = document.getElementById('resultDescription');
            const prize = prizes[missionNumber];
            prizeElement.textContent = prize.name;
            descElement.innerHTML = prize.description.replace(/\n/g, '<br>');
            result.classList.add('show');
            setTimeout(() => {
                buttons.classList.add('show');
            }, 1000);
        }
        // ---他の関数はもとのまま!---
    </script>
</body>
</html>
